# 微服务

#### 认识微服务

- 分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务
  - 优点：降低服务耦合、有利于服务升级拓展
- 微服务是一种经过良好架构设计的**分布式**架构方案，微服务架构特征：

  1. 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发
  2. 面向服务：微服务对外暴露业务接口
  3. 自治：团队独立、技术独立、数据独立、部署独立
  4. 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题（服务网关）
- 微服务：一种良好的分布式架构方案
  - 优点：拆分粒度更小、服务更独立、耦合度更低
  - 缺点：架构非常复杂，运维、监控、部署难度提高

#### 服务拆分及远程调用

- 服务拆分注意事项
  - 单一职责：不同微服务，不能重复开发相同业务
  - 数据独立：不要访问其他微服务的数据库
  - 面向服务：将自己的业务暴露为接口，供其他微服务调用
  
- 总结

  - 微服务需要根据业务模块拆分，做到单一职责,不要重复开发相同业务
  - 微服务可以将业务暴露为接口，供其它微服务使用
  - 不同微服务都应该有自己独立的数据库

- 跨服务远程调用（实际上是发送一次http请求）

  - 向spring容器里注册一个RestTemplate对象

    - ```java
      @Bean
      public RestTemplate restTemplate(){
          return new RestTemplate();
      }		
      ```

  - ​	修改业务代码

    - 自动装配restTemplate

      - ```java
        @Service
        public class OrderService {
        
            @Autowired
            private OrderMapper orderMapper;
            
            @Autowired
            private RestTemplate restTemplate;
        
            public Order queryOrderById(Long orderId) {
                // 1.查询订单
                Order order = orderMapper.findById(orderId);
        
                //2.查询用户
                String url = "http://localhost:8081/user/" + order.getUserId();
        
                User user = restTemplate.getForObject(url, User.class);
                
                //3.封装user信息
                order.setUser(user);
                // 4.返回
                return order;
            }
        }
        ```



- 微服务调用方式
  - 基于RestTemplate发起的http请求实现远程调用（此方法有缺陷，采用的是硬编码，若有多个服务，消费者该如何选择？）
  - http请求做远程调用是与语言无关的，只要知道对方的ip、端口、接口路径、请求参数即可

#### 消费者与提供者

- 服务提供者：一次业务中，被其他微服务调用的服务。（提供接口给其他微服务）
- 服务消费者：一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口）
- 总结：服务调用的关系
  - 服务提供者：暴露接口给其他服务调用
  - 服务消费者：调用其他微服务提供的接口
  - 提供者与消费者角色是相对的
  - 一个服务可以同时是服务提供者和服务消费者

#### Eureka注册中心 

- 服务调用出现的问题

  - 服务消费者该如何获取服务提供者的地址信息
  - 如果有多个服务者，消费者该如何选择
  - 消费者如何得知服务提供者的健康状态
  - 由以上三个问题，引出Eureka注册中心进行解决

- eureka的作用

  - 消费者该如何获取服务提供者具体信息？
    - 服务提供者启动时向eureka注册自己的信息
    - eureka保存这些信息
    - 消费者根据服务名称向eureka拉取提供者信息
  - 如果有多个服务提供者，消费者该如何选择？
    - 服务消费者利用负载均衡算法，从服务列表中挑选一个
  - 消费者如何感知服务提供者健康状态？
    - 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态
    - eureka会更新记录服务列表信息，心跳不正常会被剔除
    - 消费者就可以拉取到最新的信息

- 总结

  - 在Eureka架构中，微服务角色有两类
    - EurekaServer：服务端，**注册中心**
      - 记录服务信息
      - 心跳监控
    - EurekaClient：客户端
      - Provider：服务提供者，例如案例中的 user-service
        - 注册自己的信息到EurekaServer
        - 每隔30秒向EurekaServer发送心跳
      - consumer：服务消费者，例如案例中的 order-service
        - 根据服务名称从EurekaServer拉取服务列表
        - 基于服务列表做**负载均衡**，选中一个微服务后发起远程调用

- 实践

  - 搭建EurekaServer服务

    - 创建项目，引入依赖

      - ```xml
        <!--eureka服务端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        ```

    - 编写启动类，添加@EnableEurekaServer注解（开关）

      - ```java
        @EnableEurekaServer
        @SpringBootApplication
        public class EurekaApplication {
            public static void main(String[] args) {
                SpringApplication.run(EurekaApplication.class, args);
            }
        }
        ```

    - 添加application.yml文件，编写下面的配置

      - ```yml
        server:
          port: 10086 #服务端口
        spring:
          application:
            name: eurekaserver
        
        eureka:
          client:
            service-url: # eureka的地址信息
              defautZone: http://127.0.0.1:10086/eureka 
        ```

  - 注册服务到EurekaServer下

    - 先在服务项目中引入依赖

      - ```xml
        <!--eureka客户端-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        ```

    - 在配置文件中编写配置

      - ```yml
        spring:
          application:
            name: userservice
        
        eureka:
          client:
            service-url: # eureka的地址信息
              defaultZone: http://127.0.0.1:10086/eureka/
        ```

  - 模拟一个服务多个实例
    - 拷贝一个copy configuration（快捷键，ctrl + d）
    - 修改端口（vm-options ：-Dserver.port=8082）
  - 总结
    - 服务注册
      - 引入eureka-client依赖
      - 在application.yml中配置eureka地址
    - 无论是消费者还是提供者，引入eureka-client依赖、知道eureka地址后，都可以完成服务注册

- 服务发现（服务拉取）

  - 修改url路径，用服务名代替ip、端口

  - ```java
    String url = "http://userservice/user/" + order.getUserId();
    ```

  - 在服务项目启动类中的RestTemplate添加负载均衡注解

    - ```java
      @Bean
      @LoadBalanced
      public RestTemplate restTemplate(){
          return new RestTemplate();
      }
      ```

- ​	总结
  - 搭建EurekaServer
    - 引入eureka-server依赖
    - 添加@EnableEurekaServer注解
    - 在application.yml中配置eureka地址
  - 服务注册
    - 引入eureka-client依赖
    - 在application.yml中配置eureka地址
  - 服务发现
    - 引入eureka-client依赖
    - 在application.yml中配置eureka地址
    - 给RestTemplate添加@LoadBalanced注解
    - 用服务提供者的服务名称远程调用

#### Ribbon负载均衡

- Ribbon负载均衡工作流程
  - ![image-20220824165821906](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824165821906.png)





- 负载均衡策略

  - **Ribbon的负载均衡规则是一个叫做IRule的接口来定义的**，每一个子接口都是一种规则
  - ![image-20220824170049188](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824170049188.png)

  - 

  - | **内置负载均衡规则类**    | **规则描述**                                                 |
    | ------------------------- | ------------------------------------------------------------ |
    | RoundRobinRule            | 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 |
    | AvailabilityFilteringRule | 对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。 |
    | WeightedResponseTimeRule  | 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 |
    | ZoneAvoidanceRule         | 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做**轮询**。 |
    | BestAvailableRule         | 忽略那些短路的服务器，并选择并发数较低的服务器。             |
    | RandomRule                | 随机选择一个可用的服务器。                                   |
    | RetryRule                 | 重试机制的选择逻辑                                           |

- 通过定义IRule实现可以修改负载均衡规则，有两种方式

  - 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule

    - ```java
      @Bean
      public IRule randomRule(){
          return randomRule();
      }
      ```

  - 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则

    - ```yml
      userservice:  #服务名称，即在此服务中实行负载均衡
        ribbon:
          NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 
      ```

- 饥饿加载

  - Ribbon默认是采用**懒加载**，即第一次访问时才会去创建LoadBalanceClient，**请求时间会很长**。

    而**饥饿加载则会在项目启动时创建，降低第一次访问的耗时**，通过下面配置开启饥饿加载

    ```yml
    ribbon:
      eager-load:
        enabled: true #开启饥饿加载
        clients: #指定对某个服务进行饥饿加载
          - userservice
    ```

- 总结

  - Ribbon负载均衡规则
    - 规则接口是IRule
    - 默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询
  - 负载均衡自定义方式
    - 代码方式：配置灵活，但修改时需要重新打包发布
    - 配置方式：直观，方便，无需重新打包发布，但是无法做全局配置
  - 饥饿加载
    - 开启饥饿加载
    - 指定饥饿加载的微服务名称

#### Nacos注册中心

- 认识Nacos

  - [Nacos](https://nacos.io/)是阿里巴巴的产品，现在是[SpringCloud](https://spring.io/projects/spring-cloud)中的一个组件。**相比[Eureka](https://github.com/Netflix/eureka)功能更加丰富**，在国内受欢迎程度较高

- 服务注册到nacos

  - 在父工程中添加spring-cloud-alilbaba的管理依赖

    - ```xml
      <!--nacos管理依赖-->
      <dependency>
          <groupId>com.alibaba.cloud</groupId>
          <artifactId>spring-cloud-alibaba-dependencies</artifactId>
          <version>2.2.5.RELEASE</version>
          <type>pom</type>
          <scope>import</scope>
      </dependency>
      ```

  - 注释掉原有的eureka依赖

  - 添加nacos的客户端依赖

    - ```xml
      <!-- nacos客户端依赖 -->
      <dependency>
          <groupId>com.alibaba.cloud</groupId>
          <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
      </dependency>
      ```

  - 修改application.yml文件，注释eureka地址，添加nacos地址

    - ```yml
      spring
        cloud:
          nacos:
            server-addr: localhost:8845 #nacos服务地址（默认是8848）
      ```

    

  - 小结
    - Nacos服务搭建
      - 下载安装包
      - 解压
      - 在bin目录下运行指令：startup.cmd -m standalone
    - Nacos服务注册或发现
      - 引入nacos.discovery依赖
      - 配置nacos地址spring.cloud.nacos.server-addr

- Nacos服务分级存储模型

  - 服务（提供用户功能的xx服务）-->集群（杭州集群、上海集群）-->实例（端口为8081的xx服务）

  - 服务跨集群调用问题

    - 服务调用尽可能选择本地集群的服务，跨集群调用延迟较高
    - 本地集群不可访问时，再去访问其它集群

  - 服务集群属性

    - ```yml
      spring
        cloud:
          nacos:
            server-addr: localhost:8845 #nacos服务地址（默认是8848）
            discovery:
              cluster-name: HZ #集群名字，这里HZ代表杭州
      ```

  - 小结
    - Nacos服务分级存储模型
      - 一级是服务，例如userservice
      - 二级是集群，例如杭州或上海
      - 三级是实例，例如杭州机房的某台部署了userservice的服务器
    - 如何设置实例的集群属性
      - 修改application.yml文件，添加spring.cloud.nacos.discovery.cluster-name属性即可

- 根据集群负载均衡

  - 修改order-service中的application.yml，设置集群为HZ

    - ```yml
      cloud:
        nacos:
          server-addr: localhost:8845 #nacos服务地址（默认是8848）
          discovery:
            cluster-name: HZ #配置集群名称，也就是机房位置
      ```

  - 然后在order-service中设置负载均衡（默认是轮询）的IRule为NacosRule，**这个规则优先会寻找与自己同集群的服务**

    - ```yml
      userservice:
        ribbon:
          NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则
      ```

  - 小结
    - NacosRule负载均衡策略
      - 优先选择同集群服务实例列表
      - 本地集群找不到提供者，才去其它集群寻找，并且会报警告
      - 确定了可用实例列表后，再采用随机负载均衡挑选实例

- 根据权重负载均衡

  - 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求
  - Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高
  - 权重控制
    - Nacos控制台可以设置实例的权重值，0~1之间
    - 同集群内的多个实例，**权重越高被访问的频率越高**
    - 权重设置为0则完全不会被访问

- Nacos环境隔离-namespace（对服务做隔离）

  - Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离

    - 在Nacos控制台可以创建namespace，用来隔离不同环境

    - 然后填写一个新的命名空间信息

    - 保存后会在控制台看到这个命名空间的id

    - 修改order-service的application.yml，添加namespace

      - ```yml
        cloud:
          nacos:
            server-addr: localhost:8845 #nacos服务地址（默认是8848）
            discovery:
              cluster-name: HZ #配置集群名称，也就是机房位置
              namespace: e4739df6-2680-439b-acee-33e1202c0d6b #命名空间，填命名空间ID
        ```

    - 重启order-service后，再来查看控制台
    - 此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错
      - java.lang.IllegalStateException: No instances available for userservice

  - 小结

    - Nacos环境隔离
      - 每个namespace都有唯一id
      - 服务设置namespace时要写id而不是名称
      - 不同namespace下的服务互相不可见

- **nacos**注册中心细节分析

  - ![image-20220824212327974](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824212327974.png)

- **临时实例和非临时实例**

  - 服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置

    - ```yml
      cloud:
        nacos:
          server-addr: localhost:8845 #nacos服务地址（默认是8848）
          discovery:
            cluster-name: HZ #配置集群名称，也就是机房位置
            namespace: e4739df6-2680-439b-acee-33e1202c0d6b #命名空间，填命名空间ID
            ephemeral: false #是否是临时实例
      ```

  - 临时实例宕机时，会从nacos的服务列表中剔除，而非临时实例则不会

  - 小结

    - Nacos与eureka的共同点
      - 都支持服务注册和服务拉取
      - 都支持服务提供者心跳方式做健康检测
    - Nacos与Eureka的区别
      - Nacos支持服务端**主动检测**提供者状态：**临时实例采用心跳模式**，**非临时实例采用主动检测模式**（推荐使用临时实例）
      - 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
      - Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
      - Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式

#### Nacos配置管理

- 统一配置管理

  - 配置获取的步骤如下	
    - ![image-20220824214228989](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824214228989.png)

  - 注意：在填写配置信息的Data ID的时候注意结尾是.yaml不能写成-yaml，否则会报错

  - 引入Nacos的配置管理客户端依赖

    - ```xml
      <!--nacos配置管理依赖-->
      <dependency>
          <groupId>com.alibaba.cloud</groupId>
          <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
      </dependency>
      ```

  - 在userservice中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml

    - ```yml
      pring:
        application:
          name: userservice # 服务名称
        profiles:
          active: dev  #开发环境，这里是dev
        cloud:
          nacos:
            server-addr: localhost:8845  # Nacos地址
            config:
              file-extension: yaml  # 文件后缀名
      ```

  - 把application.yml里面与bootstrap.yml重复的名称删除

  - 测试

    - 我们在user-service中将pattern.dateformat这个属性注入到UserController中做测试

    - ```java
      @Value("${pattern.dateformat}")
      private String dateformat;
      
      @GetMapping("now")
      public String now(){
          return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));
      }
      ```

  - 小结
    - 将配置交给Nacos管理的步骤
      - 在Nacos中添加配置文件
      - 在微服务中引入nacos的config依赖
      - 在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件

- 配置自动刷新

  - Nacos中的配置文件变更后，微服务无需重启就可以感知

    - 方式一：在@Value注入的变量所在类上添加注解@RefreshScope

      - ```java
        @Slf4j
        @RestController
        @RefreshScope
        @RequestMapping("/user")
        ```

    - 方式二：使用@ConfigurationProperties注解（推荐使用）

      - ```java
        @Data
        @Component
        @ConfigurationProperties(prefix = "pattern")
        public class PatternProperties {
            private String dateformat;
        }
        ```

      - ```java
        @Slf4j
        @RestController
        //@RefreshScope
        @RequestMapping("/user")
        public class UserController {
        
            @Autowired
            private UserService userService;
        
            /*@Value("${pattern.dateformat}")
            private String dateformat;*/
        
            @Autowired
            private PatternProperties properties;
        
            @GetMapping("now")
            public String now(){
                return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat()));
            }
        ```

  - 小结
    - Nacos配置更改后，微服务可以实现热更新，方式
      - 通过@Value注解注入，结合@RefreshScope来刷新
      - 通过@ConfigurationProperties注入，自动刷新
    - 注意事项
      - 不是所有的配置都适合放到配置中心，维护起来比较麻烦
      - 建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置

- **多环境**配置共享

  - 微服务启动时会从nacos读取多个配置文件
    - [spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml
    - [spring.application.name].yaml，例如：userservice.yaml
    - 无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件
  - 多种配置的优先级
    - ![image-20220824224612181](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824224612181.png)

  - 小结
    - 微服务会从nacos读取的配置文件
      - [服务名]-[spring.profile.active].yaml，环境配置
      - [服务名].yaml，默认配置，多环境共享
      - 优先级
        - [服务名]-[环境].yaml >[服务名].yaml > 本地配置

- **多服务**共享配置

  - 不同微服务之间可以共享配置文件，通过下面的两种方式来指定
    - 方式一
    - 方式二

- Nacos集群搭建

  - Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档
    - ![image-20220824230207271](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220824230207271.png)

  - 集群搭建步骤
    - 搭建MySQL集群并初始化数据库表
    - 下载解压nacos
    - 修改集群配置（节点信息）、数据库配置
    - 分别启动多个nacos节点
    - nginx反向代理



#### http客户端Feign

- RestTemplate方式调用存在的问题

  - 代码可读性差，编程体验不统一
  - 参数复杂URL难以维护

- 使用Feign来替代RestTemplate

  - Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign

    其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题

- 定义和使用Feign客户端

  - 引入依赖

    - ```xml
      <!--feign客户端依赖-->
      <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-openfeign</artifactId>
      </dependency>
      ```

  - 在启动类添加注解开启Feign的功能

    - ```java
      @MapperScan("cn.itcast.order.mapper")
      @SpringBootApplication
      @EnableFeignClients
      public class OrderApplication {
      
          public static void main(String[] args) {
              SpringApplication.run(OrderApplication.class, args);
          }
      
      
          @Bean
          @LoadBalanced
          public RestTemplate restTemplate(){
              return new RestTemplate();
          }
      
      
          /*@Bean
          public IRule randomRule(){
              return new RandomRule();
          }*/
      }
      ```

  - 编写Feign客户端

    - ```java
      @FeignClient("userservice")  //服务名称
      public interface UserClient {
          @GetMapping("/user/{id}")
          User findById(@PathVariable("id") Long id);
      
      }
      ```

  - 修改代码，使用Feign客户端代替RestTemplate

    - ```java
      @Autowired
      private UserClient userClient;
      
      public Order queryOrderById(Long orderId) {
          // 1.查询订单
          Order order = orderMapper.findById(orderId);
      
          //用Feign远程调用
          User user = userClient.findById(order.getUserId());
      
          //3.封装user信息
          order.setUser(user);
          // 4.返回
          return order;
      }
      ```

  - 主要是基于SpringMVC的注解来声明远程调用的信息
    - 服务名称：userservice
    - 请求方式：GET
    - 请求路径：/user/{id}
    - 请求参数：Long id
    - 返回值类型：User
  - 小结
    - Feign的使用步骤
      - 引入依赖
      - 添加@EnableFeignClients注解
      - 编写FeignClient接口
      - 使用FeignClient中定义的方法代替RestTemplate

- 自定义Feign配置

  - Feign运行自定义配置来覆盖默认配置，可以修改的配置如下

    - | 类型                   | 作用             | 说明                                                   |
      | ---------------------- | ---------------- | ------------------------------------------------------ |
      | **feign.Logger.Level** | 修改日志级别     | 包含四种不同的级别：NONE、BASIC、HEADERS、FULL         |
      | feign.codec.Decoder    | 响应结果的解析器 | http远程调用的结果做解析，例如解析json字符串为java对象 |
      | feign.codec.Encoder    | 请求参数编码     | 将请求参数编码，便于通过http请求发送                   |
      | feign. Contract        | 支持的注解格式   | 默认是SpringMVC的注解                                  |
      | feign. Retryer         | 失败重试机制     | 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 |

  - 配置Feign日志有两种方式

    - 方式一：（暂时没实现）

      - 全局生效

        - ```yml
          eign:
            client:
              config:
                default:  # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置
                  loggerLevel: FULL #  日志级别 
          ```

      - 局部生效

        - ```yml
          feign:
            client:
              config:
                userservice:  # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置
                  loggerLever: FULL #  日志级别
          ```

    - 方式二：java代码方式，需要先声明一个Bean

      - ```java
        public class DefaultFeignConfiguration {
            @Bean
            public Logger.Level loggerLever(){
                return Logger.Level.BASIC;
            }
        }
        ```

      - 而后如果是全局配置，则把它放到@EnableFeignClients这个注解中

        - ```java
          @EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class)
          ```

      - 如果是局部配置，则把它放到@FeignClient这个注解中

        - ```java
          @FeignClient(value = "userservice" , configuration = DefaultFeignConfiguration.class)
          ```

  - 小结
    - 方式一是配置文件，feign.client.config.xxx.loggerLevel
      - 如果xxx是default则代表全局
      - 如果xxx是服务名称，例如userservice则代表某服务
    - 方式二是java代码配置Logger.Level这个Bean
      - 如果在@EnableFeignClients注解声明则代表全局
      - 如果在@FeignClient注解中声明则代表某服务

- Feign的性能优化

  - Feign底层的客户端实现

    - URLConnection：默认实现，不支持连接池
    - Apache HttpClient ：支持连接池
    - OKHttp：支持连接池

  - 因此优化Feign的性能主要包括

    - 使用连接池代替默认的URLConnection
    - 日志级别，最好用basic或none

  - 优化步骤

    - 引入依赖

      - ```xml
        <!--httpClient的依赖 -->
        <dependency>
            <groupId>io.github.openfeign</groupId>
            <artifactId>feign-httpclient</artifactId>
        </dependency>
        ```

    - 配置连接池

      - ```yml
        feign:
        #  client:
        #    config:
        #      default:  # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置
        #        loggerLever: FULL #  日志级别
        
        
          httpclient:
            enabled: true #支持HttpClient的开关
            max-connections: 200 #最大连接数
            max-connections-per-route: 50 #每个路径最大连接数
        ```

  - 小结
    - Feign的优化
      - 日志级别尽量用basic
      - 使用HttpClient或OKHttp代替URLConnection
        - 引入feign-httpClient依赖
        - 配置文件开启httpClient功能，设置连接池参数

- Feign的最佳实践

  - 方式一（继承）：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准
    - 服务紧耦合（缺）
    - 父接口参数列表中的映射不会被继承（缺）
    - ![image-20220825140845875](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825140845875.png)

  - 方式二（抽取）：将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用
    - ![image-20220825140924126](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825140924126.png)

  - 小结
    - 让controller和FeignClient继承同一接口
    - 将FeignClient、POJO、Feign的默认配置都定义到一个项目中，供所有消费者使用

- 最佳实践（抽取）

  - 首先创建一个module，命名为feign-api，然后引入feign的starter依赖

    - ```xml
      <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-openfeign</artifactId>
      </dependency>
      ```

  - 将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中

  - 在order-service中引入feign-api的依赖

    - ```xml
      <!--引入feign的统一api-->
      <dependency>
          <groupId>cn.itcast.demo</groupId>
          <artifactId>feign-api</artifactId>
          <version>1.0</version>
      </dependency>
      ```

  - 修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包

  - 重启测试

  - 当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决（注意）

    - 方式一：指定FeignClient所在包

      - ```java
        @EnableFeignClients(basePackages = "cn.itcast.feign.client", clients = UserClient.class, defaultConfiguration = DefaultFeignConfiguration.class)
        ```

    - 方式二：指定FeignClient字节码（推荐）

      - ```java
        @EnableFeignClients(clients = UserClient.class, defaultConfiguration = DefaultFeignConfiguration.class)
        ```

#### 统一网关

- ![image-20220825143644914](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825143644914.png)

- 为什么需要网关

  - 使用[网关](https://so.csdn.net/so/search?q=网关&spm=1001.2101.3001.7020)可以统一进行鉴权，如果在微服务系统中不使用网关那么在每一个微服务中都需要进行鉴权，不仅增加系统的复杂性，而且也影响用户体验
  - 使用网关鉴权可以有效的**保护[微服务](https://so.csdn.net/so/search?q=微服务&spm=1001.2101.3001.7020)**，只暴露自己的网关，将其他的微服务可以隐藏在内网中通过防火墙进行保护
  - 易于监控，可以在网关中直接统一收集监控数据并将其推送到外部系统进行分析
  - 减少客户端与各个微服务之间的交互次数 

- 网关功能

  - 身份认证和权限校验
  - 服务路由，负载均衡
  - 请求限流

- 网关技术的实现

  - Nginx:nginx是一个高性能的HTTP和反向代理web服务器
  - 在SpringCloud中网关的实现包括两种
    - gateway
    - zuul
    - Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能

- 搭建网关服务

  - 创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖

    - ```xml
      <!--nacos服务发现依赖-->
      <dependencies>
          <dependency>
              <groupId>com.alibaba.cloud</groupId>
              <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
          </dependency>
      
          <!--网关依赖-->
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-gateway</artifactId>
          </dependency>
      </dependencies>
      ```

  - 2.编写路由配置及nacos地址

    - ```yml
      server:
        port: 10010 #网关端口
      spring:
        application:
          name: gateway #服务名称
      
        cloud:
          nacos:
            server-addr: localhost:8845 #nacos地址
      
          gateway:
            routes: #网关路由配置
              - id: user-service #路由id，自定义，只要唯一即可
                uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称
                predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
                  - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
      ```

  - ![image-20220825152803385](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825152803385.png)

  - 小结
    - 网关搭建步骤
      - 创建项目，引入nacos服务发现和gateway依赖
      - 配置application.yml，包括服务基本信息、nacos地址、路由
    - 路由配置包括
      - 路由id：路由的唯一标示
      - 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡
      - 路由断言（predicates）：判断路由的规则，
      - 路由过滤器（filters）：对请求或响应做处理

- 路由断言工厂

  - 网关路由可以配置的内容包括

    - 路由id：路由唯一标示
    - uri：路由目的地，支持lb和http两种
    - predicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地
    - filters：路由过滤器，处理请求或响应

  - 路由断言工厂

    - 我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件

    - 例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的

    - 像这样的断言工厂在SpringCloudGateway还有十几个

    - Spring提供了11种基本的Predicate工厂

      - | **名称**   | **说明**                       | **示例**                                                     |
        | ---------- | ------------------------------ | ------------------------------------------------------------ |
        | After      | 是某个时间点后的请求           | -  After=2037-01-20T17:42:47.789-07:00[America/Denver]       |
        | Before     | 是某个时间点之前的请求         | -  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]       |
        | Between    | 是某两个时间点之前的请求       | -  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver] |
        | Cookie     | 请求必须包含某些cookie         | - Cookie=chocolate, ch.p                                     |
        | Header     | 请求必须包含某些header         | - Header=X-Request-Id, \d+                                   |
        | Host       | 请求必须是访问某个host（域名） | -  Host=**.somehost.org,**.anotherhost.org                   |
        | Method     | 请求方式必须是指定方式         | - Method=GET,POST                                            |
        | Path       | 请求路径必须符合指定规则       | - Path=/red/{segment},/blue/**                               |
        | Query      | 请求参数必须包含指定参数       | - Query=name, Jack或者-  Query=name                          |
        | RemoteAddr | 请求者的ip必须是指定范围       | - RemoteAddr=192.168.1.1/24                                  |
        | Weight     | 权重处理                       |                                                              |

    - 小结
      - PredicateFactory的作用是什么
        - 读取用户定义的断言条件，对请求做出判断
      - Path=/user/**是什么含义
        - 路径是以/user开头的就认为是符合的

  - 路由过滤器

    - GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理
      - ![image-20220825201726953](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825201726953.png)

    - Spring提供了31种不同的路由过滤器工厂。例如

      - | **名称**             | **说明**                     |
        | -------------------- | ---------------------------- |
        | AddRequestHeader     | 给当前请求添加一个请求头     |
        | RemoveRequestHeader  | 移除请求中的一个请求头       |
        | AddResponseHeader    | 给响应结果中添加一个响应头   |
        | RemoveResponseHeader | 从响应结果中移除有一个响应头 |
        | RequestRateLimiter   | 限制请求的流量               |
        | ...                  |                              |

    - 案例：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!

      - 在gateway中修改application.yml文件，给userservice的路由添加过滤器

        - ```yml
          server:
            port: 10010 #网关端口
          spring:
            application:
              name: gateway #服务名称
          
            cloud:
              nacos:
                server-addr: localhost:8845 #nacos地址
          
              gateway:
                routes: #网关路由配置
                  - id: user-service #路由id，自定义，只要唯一即可
                    uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称
                    predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
                      - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
                    filters: # 过滤器
                      - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
          
          
                  - id: order-service
                    uri: lb://orderservice
                    predicates:
                      - Path=/order/**
          ```

      - 如果要对所有的路由都生效，则可以将过滤器工厂写到default下

        - ```yml
          server:
            port: 10010 #网关端口
          spring:
            application:
              name: gateway #服务名称
          
            cloud:
              nacos:
                server-addr: localhost:8845 #nacos地址
          
              gateway:
                routes: #网关路由配置
                  - id: user-service #路由id，自定义，只要唯一即可
                    uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称
                    predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
                      - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
          #          filters: # 过滤器
          #            - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
          
          
                  - id: order-service
                    uri: lb://orderservice
                    predicates:
                      - Path=/order/**
                default-filters:
                  - AddRequestHeader=Truth, Itcast is freaking awesome!
          ```

      - 小结
        - 过滤器的作用是什么
          - 对路由的请求或响应做加工处理，比如添加请求头
          - 配置在路由下的过滤器只对当前路由的请求生效
        - defaultFilters的作用是什么
          - 对所有路由都生效的过滤器

  - 全局过滤器**GlobalFilter**

    - 全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。

      区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。

      定义方式是实现GlobalFilter接口

    - 案例：定义全局过滤器，拦截并判断用户身份

      - 需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件

        - 参数中是否有authorization

        - authorization参数值是否为admin

        - 如果同时满足则放行，否则拦截

          ```java
          @Order(-1)  //顺序注解,值越小，优先级越高
          @Component   //注入到spring容器中，作为一个Bean
          public class AuthorizeFilter implements GlobalFilter {
              @Override
              public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                  //1获取请求参数
                  ServerHttpRequest request = exchange.getRequest();
                  MultiValueMap<String, String> params = request.getQueryParams();
          
          
                  //2.获取参数中的authorization参数
                  String auth = params.getFirst("authorization");
          
          
                  //3.判断参数值是否等于admin
                  if ("admin".equals(auth)){
          
                      //4.是就放行
                      return chain.filter(exchange);
                  }
          
                  //5.不是就拦截
          
                  //5.1设置状态码
                  exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
          
                  return exchange.getResponse().setComplete();
          
              }
          }
          ```

    - 小结
      - 全局过滤器的作用是什么
        - 对所有路由都生效的过滤器，并且可以自定义处理逻辑
      - 实现全局过滤器的步骤
        - 实现GlobalFilter接口
        - 添加@Order注解或实现Ordered接口
        - 编写处理逻辑

  - **过滤器执行顺序**

    - 请求进入网关会碰到三类过滤器：当前路由的下过滤器、DefaultFilter、GlobalFilter
    - 请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器
    - ![image-20220825210021550](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825210021550.png)

    - 执行顺序
      - 每一个过滤器都必须指定一个int类型的order值，**order**值越小，优先级越高，执行顺序越靠前
      - GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定
      - 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。
      - 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行
        - **org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()**方法是先加载defaultFilters，然后再加载某个route的filters，然后合并
        - **org.springframework.cloud.gateway.handler.FilteringWebHandler#handle**()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链
    - 小结
      - 路由过滤器、defaultFilter、全局过滤器的执行顺序
        - order值越小，优先级越高
        - 当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器

  - 跨域问题处理

    跨域：域名不一致就是跨域，主要包括

    - 域名不同： :www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com
    - 域名相同，端口不同：localhost8080和localhost8081

    - 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题

    - 解决方案：CORS

    - 网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现

    - ```yml
      spring:
        cloud:
          gateway:
            globalcors: # 全局的跨域处理
              add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题
              corsConfigurations:
                '[/**]':
                  allowedOrigins: # 允许哪些网站的跨域请求
                    - "http://localhost:8090"
                    - "http://www.leyou.com"
                  allowedMethods: # 允许的跨域ajax的请求方式
                    - "GET"
                    - "POST"
                    - "DELETE"
                    - "PUT"
                    - "OPTIONS"
                  allowedHeaders: "*" # 允许在请求中携带的头信息
                  allowCredentials: true # 是否允许携带cookie
                  maxAge: 360000 # 这次跨域检测的有效期
      ```





#### Docker

- 项目部署问题

  - 大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题
    - 依赖关系复杂，容易出现兼容性问题
    - 开发、测试、生产环境有差异
  - Docker如何解决依赖的兼容问题的
    - 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包
    - 将每个应用放到一个隔离**容器**去运行，避免互相干扰
    - ![image-20220825213010680](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825213010680.png)

  - 不同环境的操作系统不同，Docker如何解决

    - 内核与硬件交互，提供操作硬件的指令

      系统应用封装内核指令为函数，便于程序员调用

      用户程序基于系统函数库实现功能

    - Ubuntu和CentOS都是基于Linux内核，只是系统应用不同，提供的函数库有差异

    - Docker如何解决不同系统环境的问题

      - Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包
      - Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行

    - Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题

      - Docker允许开发中将应用、依赖、函数库、配置一起**打包**，形成可移植镜像
      - Docker应用运行在容器中，使用沙箱机制，相互**隔离**

    - Docker如何解决开发、测试、生产环境有差异的问题

      - Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行

  - 小结

    - Docker是一个快速交付应用、运行应用的技术
      - 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统
      - 运行时利用沙箱机制形成隔离容器，各个应用互不干扰
      - 启动、移除都可以通过一行命令完成，方便快捷

  - **Docker**与虚拟机

    - ![image-20220825213718903](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825213718903.png)

  - Docker和虚拟机的差异
    - docker是一个系统进程；虚拟机是在操作系统中的操作系统
    - docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般

- **镜像和容器**

  - **镜像**（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像
  - **容器（**Container）**：镜像中的应用程序运行后形成的进程就是**容器，只是Docker会给容器做隔离，对外不可见

- Docker架构

  - Docker是一个CS架构的程序，由两部分组成
    - 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等
    - 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令
    - ![image-20220825214020792](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825214020792.png)

  - 小结
    - 镜像
      - 将应用程序及其依赖、环境、配置打包在一起
    - 容器
      - 镜像运行起来就是容器，一个镜像可以运行多个容器
    - Docker结构
      - 服务端：接收命令或远程请求，操作镜像或容器
      - 客户端：发送命令或者请求到Docker服务端
    - DockerHub
      - 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry
    - 什么是Docker
      - 帮助我们快速构建应用镜像、交付应用、运行应用的技术
    - Docker工作流
      - 构建自定义镜像或者从DockerRegistry拉取镜像
      - 根据镜像创建容器，并运行
  
- Docker基本操作

  - 镜像相关命令

    - 镜像名称一般分两部分组成：[repository]:[tag]
    - 在没有指定tag时，默认是latest，代表最新版本的镜像
    - **镜像操作命令**
      - ![image-20220825224604122](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825224604122.png)


    - 镜像操作有哪些
      - docker images、docker rmi、docker pull、 docker push、 docker save、 docker load

  - 容器相关命令

    - ![image-20220825225634336](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220825225634336.png)

    - docker run命令的常见参数有哪些
      - --name：指定容器名称
      - -p：指定端口映射
      - -d：让容器后台运行
    - 查看容器日志命令
      - docker logs
      - 添加-f参数可以持续查看日志
    - 查看容器状态
      - docker ps
    - 运行已经创建好的容器
      - docker start 容器名字
    - 删除容器
      - docker rm
      - 不能删除运行中的容器，加-f参数可强制删除
    - 进入容器
      - 命令是docker exec -it [容器名] [要执行的命令]
      - exec命令可以进入容器修改文件，但是在容器内修改文件是不推荐的

  - 数据卷

    **数据卷**(volume）是一个虚拟目录，指向宿主机文件系统中的某个目录

    - ![image-20220826142512029](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826142512029.png)

    - 容器与数据耦合的问题
      - ![image-20220826142806434](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826142806434.png)

    - 数据卷操作的基本语法如下

      - docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作
        - create：创建一个volume
        - inspect： 显示一个或多个volume的信息
        - ls： 列出所有的volume
        - prune： 删除未使用的volume
        - rm： 删除一个或多个指定的volume

    - 数据卷的作用

      - 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全

    - 挂载数据卷

      - 在创建容器时，可以通过-v参数来挂载一个数据卷到某个容器目录
        - ![image-20220826143420479](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826143420479.png)

      - 上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置**/usr/share/nginx/html** ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容
        - 创建容器并挂载数据卷到容器内的HTML目录
          - docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx
        - 进入html数据卷所在位置，并修改HTML内容
          - 查看html数据卷的位置：docker volume inspect html
          - 进入该目录：cd /var/lib/docker/volumes/html/_data
          - 可用外部编辑器进行编辑
        - 数据卷挂载方式
          - -v volumeName: /targetContainerPath
          - 如果容器运行时volume不存在，会自动被创建出来
      - 案例：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器
        - 目录挂载与数据卷挂载的语法是类似的
          - -v [宿主机目录]:[容器内目录]
          - -v [宿主机文件]:[容器内文件]
        - 实现思路如下
          - 在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像
          - 创建目录/tmp/mysql/data
          - 创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf
          - 去DockerHub查阅资料，创建并运行MySQL容器，要求
            - 挂载/tmp/mysql/data到mysql容器内数据存储目录
            - 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件
            - 设置MySQL密码
            - 命令
              - docker run \
                	--name mysql \
                	-e MYSQL_ROOT_PASSWORD=cm20020725 \
                	-p 3306:3306 \
                	-v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \
                	-v /tmp/mysql/data:/var/lib/mysql \
                	-d mysql:5.7.25
        - **数据卷挂载的方式对比**
          - ![image-20220826152518225](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826152518225.png)

      - 小结
        - docker run的命令中通过 -v 参数挂载文件或目录到容器中
          - -v volume名称:容器内目录
          - -v 宿主机文件:容器内文件
          - -v 宿主机目录:容器内目录
        - 1.数据卷挂载与目录直接挂载的区别
          - 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找
          - 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看

- Dockerfile自定义镜像

  - 镜像结构

    - 镜像组成	
      - 镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成

    - ![image-20220826153910056](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826153910056.png)

    - 小结
      - 镜像是分层结构，每一层称为一个Layer
        - BaseImage层：包含基本的系统函数库、环境变量、文件系统
        - Entrypoint：入口，是镜像中应用启动的命令
        - 其它：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置

  - Dockerfile

    - **Dockerfile**就是一个文本文件，其中包含一个个的**指令****(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer

      - | **指令**   | **说明**                                     | **示例**                    |
        | ---------- | -------------------------------------------- | --------------------------- |
        | FROM       | 指定基础镜像                                 | FROM centos:6               |
        | ENV        | 设置环境变量，可在后面指令使用               | ENV key value               |
        | COPY       | 拷贝本地文件到镜像的指定目录                 | COPY ./mysql-5.7.rpm /tmp   |
        | RUN        | 执行Linux的shell命令，一般是安装过程的命令   | RUN yum install gcc         |
        | EXPOSE     | 指定容器运行时监听的端口，是给镜像使用者看的 | EXPOSE 8080                 |
        | ENTRYPOINT | 镜像中应用的启动命令，容器运行时调用         | ENTRYPOINT java -jar xx.jar |

      - 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder

    - 基于java:8-alpine镜像，将一个Java项目构建为镜像

      - 实现思路
        - 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile
        - 拷贝课前资料提供的docker-demo.jar到这个目录中
        - 编写Dockerfile文件：
          - 基于java:8-alpine作为基础镜像
          - 将app.jar拷贝到镜像中
          - 暴露端口
          - 编写入口ENTRYPOINT
          - 指定基础镜像：FROM java:8-alpine
          - COPY ./docker-demo.jar /tmp/app.jar
          - 暴露端口：EXPOSE 8090
          - 入口，java项目启动命令：ENTRYPOINT java -jar /tmp/app.jar

        - 使用docker build命令构建镜像
        - 使用docker run创建容器并运行

    - 小结

      - Dockerfile的本质是一个文件，通过指令描述镜像的构建过程
      - Dockerfile的第一行必须是FROM，从一个基础镜像来构建
      - 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine

  - DockerCompose

    - Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器
    - Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行
      - ![image-20220826161006755](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826161006755.png)


    - •DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/
    - 小结
      - DockerCompose有什么作用
        - 帮助我们快速部署分布式应用，无需一个个微服务去构建镜像和部署


#### 初识MQ

- 同步通讯和异步通讯

  - 同步调用存在的问题
    - ![image-20220826205125959](C:\Users\22906\AppData\Roaming\Typora\typora-user-images\image-20220826205125959.png)

  - 同步调用的优点
    - 时效性较强，可以立即得到结果
  - 同步调用的问题
    - 耦合度高
    - 性能和吞吐能力下降
    - 有额外的资源消耗
    - 有级联失败问题
  - 异步调用
    - 异步调用常见实现就是事件驱动模式
  - 异步通信的优点
    - 耦合度低
    - 吞吐量提升
    - 故障隔离
    - 流量削峰
  - 异步通信的缺点
    - 依赖于Broker的可靠性、安全性、吞吐能力
    - 架构复杂了，业务没有明显的流程线，不好追踪管理

- 什么是MQ

  - MQ （MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker

- RabbitMQ

  - RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/

