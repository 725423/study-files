# 计算机网络

### http和https的区别

- 端口
  - https的端口是443，而http的端口是80，当然两者的连接方式也是不太一样的
- 传输数据
  - http传输是明文的，而https是用ssl进行加密的。https具有安全性
- 申请证书
  - https传输一般是需要申请证书，申请证书可能会需要一定的费用



### 为什么网络要分层

- **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理**
- **提高了整体灵活性** ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的**
- **大问题化小** ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义**
- **计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的**（感言）



### TCP 与 UDP 的区别（重要）

- **是否面向连接** ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。

- **是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有**三次握手来建立连接**，而且在**数据传递时**，**有确认、窗口、重传、拥塞控制机制**。通过 TCP 连接传输的数据，**无差错、不丢失、不重复、并且按序到达**。

- **是否有状态** ：这个和上面的“是否可靠传输”相对应。**TCP 传输是有状态的**，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 **UDP 是无状态服务**，简单来说就是不管发出去之后的事情了（**这很渣男！**）。

- **传输效率** ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。

- **传输形式** ： **TCP 是面向字节流的**，**UDP 是面向报文的**。

- **首部开销** ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。

- **是否提供广播或多播服务** ：TCP 只支持**点对点通信**，UDP 支持**一对一、一对多、多对一、多对多**

- | TCP                    | UDP            |            |
  | ---------------------- | -------------- | ---------- |
  | 是否面向连接           | 是             | 否         |
  | 是否可靠               | 是             | 否         |
  | 是否有状态             | 是             | 否         |
  | 传输效率               | 较慢           | 较快       |
  | 传输形式               | 字节流         | 数据报文段 |
  | 首部开销               | 20 ～ 60 bytes | 8 bytes    |
  | 是否提供广播或多播服务 | 否             | 是         |



### 什么时候选择 TCP,什么时候选 UDP

- **UDP 一般用于即时通信**，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。
- **TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等



### HTTP 基于 TCP 还是 UDP

- **HTTP 协议是基于 TCP 协议的**，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手



### TCP 三次握手和四次挥手（非常重要）

- ##### 为什么要三次握手

  - 三次握手的目的是**建立可靠的通信信道**，说到通讯，简单来说就是数据的发送与接收，而三次握手**最主要的目的就是双方确认自己与对方的发送与接收是正常的**
    - **第一次握手** ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
    - **第二次握手** ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
    - **第三次握手** ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

- ##### 第2次握手传回了ACK，为什么还要传回SYN

  - 服务端传回发送端所发送的 **ACK** 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从**客户端到服务端的通信是正常的**。回传 **SYN** 则是**为了建立并确认从服务端到客户端的通信**
    - **SYN** 同步序列编号(Synchronize Sequence Numbers) 是 **TCP/IP 建立连接时使用的握手信号**。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递

- ##### 四次挥手

  - **第一次挥手** ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 **FIN-WAIT-1** 状态。
  - **第二次挥手** ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。然后，此时服务端进入**CLOSE-WAIT**状态，客户端进入**FIN-WAIT-2**状态。
  - **第三次挥手** ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入**LAST-ACK**状态。
  - **第四次挥手** ：客户端发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入**TIME-WAIT**状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了
    - **只要四次挥手没有结束，客户端和服务端就可以继续传输数据**

- ##### 为什么要四次挥手 

  - TCP是**全双工通信**，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接
    - **第一次挥手** ： A 说“我没啥要说的了”
    - **第二次挥手** ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
    - **第三次挥手** ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
    - **第四次挥手** ：A 回答“知道了”，这样通话才算结束

- ##### 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手

  - 因为服务器**收到客户端断开连接的请求**时，**可能还有一些数据没有发完**，这时**先回复 ACK**，表示接收到了断开连接的请求。等到**数据发完之后再发 FIN**，**断开服务器到客户端的数据传送**

- ##### 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样

  - 客户端没有收到 ACK 确认，会**重新发送 FIN 请求**

- ##### 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态

  - 第四次挥手时，客户端发送给服务器的 **ACK 有可能丢失**，如果服务端没有因为某些原因而**没有收到 ACK** 的话，服务端就会**重发 FIN**，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN
    - **MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接





### TCP 传输可靠性保障（传输层）？（重要）

- ##### TCP 如何保证传输的可靠性？

  - **基于数据快传输** ：应用数据被分割成 TCP 认为**最适合发送的数据块**，再传输给网络层，**数据块被称为报文段或段**。
  - **对失序数据包重新排序以及去重**：TCP 为了保证不发生丢包，就给每个包一个**序列号**，有了序列号能够将接收到的数据**根据序列号排序**，并且去掉重复序列号的数据就可以实现数据包去重。
  - **校验和** : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
  - **超时重传** : 当发送方发送数据之后，它启动一个**定时器**，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（**ACK**）。如果发送端实体在**合理的往返时延（RTT）内未收到确认消息**，那么对应的数据包就被假设为[已丢失open in new window](https://zh.wikipedia.org/wiki/丢包)并进行**重传**。
  - **流量控制** : TCP 连接的每一方都有固定大小的**缓冲空间**，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。**TCP 使用的流量控制协议是可变大小的滑动窗口协议**（**TCP 利用滑动窗口实现流量控制**）。
  - **拥塞控制** : 当网络拥塞时，减少数据的发送

- ##### TCP 如何实现流量控制

  - **TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据

- **为什么需要流量控制?** 

  - 因为双方在通信的时候，**发送方的速率与接收方的速率是不一定相等**，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 **接收缓冲区(Receiving Buffers)** 里（**失序的数据包也会被存放在缓存区里**）。如果缓存区**满了**发送方还在**狂发数据**的话，接收方只能把**收到的数据包丢掉**。出现**丢包问题**的同时又**疯狂浪费着珍贵的网络资源**。因此，我们需要控制发送方的发送速率，让接收方与发送方**处于**一种**动态平衡**才好
  - 注意
    - 发送端不等同于客户端
    - 接收端不等同于服务端
  - TCP 为**全双工(Full-Duplex, FDX)通信**，双方可以进行**双向通信**，**客户端和服务端既可能是发送端又可能是服务端**。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同

- **TCP 发送窗口可以划分成四个部分**

  - 已经发送并且确认的TCP段（已经发送并确认）；

  - 已经发送但是没有确认的TCP段（已经发送未确认）；

  - 未发送但是接收方准备接收的TCP段（可以发送）；

  - 未发送并且接收方也并未准备接受的TCP段（不可发送）

  - **TCP发送窗口结构图示** ：

    ![TCP发送窗口结构](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png)

    - **SND.WND** ：发送窗口。
    - **SND.UNA**：Send Unacknowledged 指针，指向发送窗口的第一个字节。
    - **SND.NXT**：Send Next 指针，指向可用窗口的第一个字节。

    **可用窗口大小** = `SND.UNA + SND.WND - SND.NXT`

- **TCP 接收窗口可以划分成三个部分** 

  - 已经接收并且已经确认的 TCP 段（已经接收并确认）；

  - 等待接收且允许发送方发送 TCP 段（可以接收未确认）；

  - 不可接收且不允许发送方发送TCP段（不可接收）

  - **TCP 接收窗口结构图示** ：

    ![TCP接收窗口结构](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-receive-window.png)

    **接收窗口的大小是根据接收端处理数据的速度动态调整的。** 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。

    另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值

- ##### TCP 的拥塞控制是怎么实现的

  - 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫**拥塞**
  - 拥塞控制就是为了**防止过多的数据注入到网络中**，这样就可以**使网络中的路由器或链路不致过载**
  - 拥塞控制所要做的都有一个**前提**，就是**网络能够承受现有的网络负荷**。拥塞控制是一个**全局性的过程**，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素
  - 相反，**流量控制往往是点对点通信量的控制**，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
  - 为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个
  - TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生
    - **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
    - **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.
    - **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作

- ##### ARQ 协议了解吗

  - **自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数（ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议）

  - ##### 停止等待 ARQ 协议

    - 停止等待协议是**为了实现可靠传输的**，它的**基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）**。如果过了一段时间（超时时间后），还是**没有收到 ACK 确认**，说明没有发送成功，需要**重新发送**，直到收到确认后再发下一个分组
    - 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认
    - **无差错情况**
      - 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送
    -  **出现差错情况（超时重传）**
    - **出现差错情况（超时重传）**
      - 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认
    - **确认丢失和确认迟到**
      - **确认丢失** ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。
      - **确认迟到** ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1

  - ##### 连续 ARQ 协议

    - 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

      **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

      **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息




### Get和Post的区别

- get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据），post请求一般是去提交数据

- get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内，post请求是没有的长度限制，请求数据是放在body中

- get请求**刷新服务器或者回退没有影响**，post请求**回退时会重新提交数据请求**

- get请求可以被缓存，post请求不会被缓存

  - get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中

- get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）

- **报文上的区别**

  - GET 和 POST 只是 HTTP 协议中两种请求方式，所以在传输上，没有区别，因为HTTP 协议是基于 TCP/IP 的应用层协议报文格式上，不带参数时，最大区别仅仅是第一行方法名不同，一个是GET，一个是POST带参数时报文的区别呢？在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中，举个例子，如果参数是 name=qiming.c, age=22。
    GET 方法简约版报文可能是这样的 
    GET /index.php?name=qiming.c&age=22 HTTP/1.1
    Host: localhost

    POST 方法简约版报文可能是这样的 
     POST /index.php HTTP/1.1
     Host: localhost 
     Content-Type: application/x-www-form-urlencoded name=qiming. c&age=22

- **GET 方法参数写法是固定的吗**

  - 在约定中，一般我们的参数是写在 ? 后面，用 & 分割。
    我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。
    也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是这样 :
    http://www.example.com/user/name/yourname/age/22

- **POST 方法比 GET 方法安全？**

  - 按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。
    然而从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输，只要在网络节点上抓包，就能完整地获取数据报文。
    要想安全传输，就只有加密，也就是 HTTPS



### HTTP 和 HTTPS 有什么区别？（重要）

- **端口号** ：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是**明文**，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过**加密**，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，**HTTP 安全性没有 HTTPS 高**，但是 **HTTPS 比 HTTP 耗费更多服务器资源**。



###  HTTP 1.0 和 HTTP 1.1 有什么区别？

- **连接方式** : HTTP 1.0 为**短连接**，HTTP 1.1 **支持长连接**。
- **状态响应码** : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存处理** : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host头处理** : HTTP/1.1在请求头中加入了`Host`字段





### HTTP 是不保存状态的协议, 如何保存用户状态?

- HTTP 是一种不保存状态，即**无状态（stateless）协议**。也就是说 HTTP 协议**自身不对请求和响应之间的通信状态进行保存**。那么我们保存用户状态呢？**Session 机制**的存在就是为了解决这个问题，Session 的主要作用就是通过**服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

  在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪

- **Cookie 被禁用怎么办**

  - 最常用的就是利用 **URL 重写**把 Session ID 直接附加在 URL 路径的后面



### URI 和 URL 的区别是什么

- URI(Uniform Resource Identifier) 是统一资源**标志符**，可以**唯一标识一个资源**。
- URL(Uniform Resource Locator) 是统一资源**定位符**，可以**提供该资源的路径**。它是一种**具体的 URI**，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源
- **URI** 的作用像**身份证号一样**，**URL** 的作用更像**家庭住址**一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息




